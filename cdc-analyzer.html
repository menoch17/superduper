<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDC Messaging Analyzer - Law Enforcement Tool</title>
    <style>
        :root {
            --primary-color: #1a365d;
            --secondary-color: #2c5282;
            --success-color: #276749;
            --warning-color: #c05621;
            --danger-color: #c53030;
            --info-color: #2b6cb0;
            --bg-color: #f7fafc;
            --card-bg: #ffffff;
            --text-color: #1a202c;
            --text-muted: #718096;
            --border-color: #e2e8f0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        header p {
            opacity: 0.9;
            font-size: 0.95rem;
        }

        .input-section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .input-section h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            resize: vertical;
            transition: border-color 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: var(--secondary-color);
        }

        .button-row {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
        }

        .btn-secondary {
            background-color: #e2e8f0;
            color: var(--text-color);
        }

        .btn-secondary:hover {
            background-color: #cbd5e0;
        }

        .results-container {
            display: none;
        }

        .results-container.active {
            display: block;
        }

        /* Summary Cards */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .summary-card h3 {
            font-size: 1rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        .summary-card.highlight {
            border-left: 4px solid var(--info-color);
        }

        .summary-card.caller {
            border-left: 4px solid var(--success-color);
        }

        .summary-card.called {
            border-left: 4px solid var(--warning-color);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--text-muted);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .info-value {
            font-weight: 600;
            text-align: right;
            max-width: 60%;
            word-break: break-word;
        }

        .phone-number {
            font-size: 1.3rem;
            color: var(--primary-color);
            font-weight: 700;
            font-family: 'Consolas', monospace;
        }

        .caller-name {
            font-size: 1.1rem;
            color: var(--success-color);
            font-weight: 600;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-success {
            background-color: #c6f6d5;
            color: #276749;
        }

        .badge-warning {
            background-color: #feebc8;
            color: #c05621;
        }

        .badge-info {
            background-color: #bee3f8;
            color: #2b6cb0;
        }

        .badge-danger {
            background-color: #fed7d7;
            color: #c53030;
        }

        /* Timeline */
        .timeline-section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .timeline-section h3 {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 20px;
        }

        .timeline {
            position: relative;
            padding-left: 30px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-event {
            position: relative;
            padding: 15px;
            margin-bottom: 15px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .timeline-event::before {
            content: '';
            position: absolute;
            left: -26px;
            top: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--info-color);
            border: 2px solid white;
            box-shadow: 0 0 0 2px var(--info-color);
        }

        .timeline-event.event-start::before {
            background: var(--success-color);
            box-shadow: 0 0 0 2px var(--success-color);
        }

        .timeline-event.event-end::before {
            background: var(--danger-color);
            box-shadow: 0 0 0 2px var(--danger-color);
        }

        .timeline-event.event-answer::before {
            background: var(--success-color);
            box-shadow: 0 0 0 2px var(--success-color);
        }

        .timeline-event.event-ring::before {
            background: var(--warning-color);
            box-shadow: 0 0 0 2px var(--warning-color);
        }

        .timeline-time {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: 'Consolas', monospace;
        }

        .timeline-title {
            font-weight: 600;
            margin: 5px 0;
            color: var(--primary-color);
        }

        .timeline-details {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Device Info */
        .device-section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .device-section h3 {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .device-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .device-item {
            padding: 15px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .device-item h4 {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .device-item p {
            font-weight: 600;
            word-break: break-word;
        }

        /* Location Section */
        .location-section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .location-section h3 {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .location-item {
            padding: 15px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            margin-bottom: 10px;
        }

        .location-item:last-child {
            margin-bottom: 0;
        }

        .cell-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .cell-detail {
            padding: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .cell-detail label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .cell-detail span {
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }

        /* Technical Details */
        .technical-section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .technical-section h3 {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .technical-section h3::after {
            content: '\25BC';
            font-size: 0.8rem;
            transition: transform 0.3s;
        }

        .technical-section.collapsed h3::after {
            transform: rotate(-90deg);
        }

        .technical-content {
            display: block;
        }

        .technical-section.collapsed .technical-content {
            display: none;
        }

        .sip-message {
            background: #1a202c;
            color: #68d391;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
            margin-bottom: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .message-type-label {
            display: inline-block;
            padding: 4px 8px;
            background: var(--secondary-color);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        /* Raw Data Toggle */
        .raw-data-section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .raw-data-section h3 {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            cursor: pointer;
        }

        /* Explanation Panel */
        .explanation-panel {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .explanation-panel h3 {
            color: var(--info-color);
            margin-bottom: 10px;
        }

        .explanation-panel p {
            color: #2c5282;
            font-size: 0.95rem;
        }

        .explanation-panel ul {
            margin-top: 10px;
            padding-left: 20px;
        }

        .explanation-panel li {
            color: #2c5282;
            margin-bottom: 5px;
        }

        /* Audio Codec Info */
        .codec-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .codec-badge {
            background: #e2e8f0;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-family: 'Consolas', monospace;
        }

        /* SMS Message Styling */
        .sms-bubble {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            margin: 8px 0;
            position: relative;
        }

        .sms-bubble.incoming {
            background: #e2e8f0;
            color: #1a202c;
            margin-right: auto;
            border-bottom-left-radius: 4px;
        }

        .sms-bubble.outgoing {
            background: #3182ce;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }

        .timeline-event.event-sms::before {
            background: #9f7aea;
            box-shadow: 0 0 0 2px #9f7aea;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            header h1 {
                font-size: 1.4rem;
            }

            .summary-grid {
                grid-template-columns: 1fr;
            }

            .phone-number {
                font-size: 1.1rem;
            }
        }

        /* Print styles */
        @media print {
            .input-section, .button-row {
                display: none;
            }

            .results-container {
                display: block !important;
            }

            .technical-section.collapsed .technical-content {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>CDC Messaging Analyzer</h1>
            <p>CALEA/LAES Intercept Data Parser - Law Enforcement Use Only</p>
        </header>

        <div class="input-section">
            <h2>Paste CDC Data Below</h2>
            <textarea id="cdcInput" placeholder="Paste your CDC/LAES messaging data here...

Example message types this tool can parse:
- termAttempt / origAttempt (Call attempts)
- directSignalReporting (SIP signaling)
- ccOpen / ccClose (Content channel)
- answer (Call answered)
- release (Call ended)
- SMS/MMS messages"></textarea>
            <div class="button-row">
                <button class="btn-primary" onclick="analyzeCDC()">Analyze CDC Data</button>
                <button class="btn-secondary" onclick="clearAll()">Clear</button>
                <button class="btn-secondary" onclick="loadSample()">Load Sample</button>
            </div>
        </div>

        <div class="results-container" id="resultsContainer">
            <!-- Results will be inserted here -->
        </div>
    </div>

    <script>
        // CDC Parser and Analyzer

        class CDCAnalyzer {
            constructor(rawData) {
                this.rawData = rawData;
                this.messages = [];
                this.smsMessages = []; // Track SMS messages separately
                this.callInfo = {
                    caseId: null,
                    callId: null,
                    callingParty: {},
                    calledParty: {},
                    callerName: null,
                    startTime: null,
                    answerTime: null,
                    endTime: null,
                    duration: null,
                    callType: null,
                    callDirection: null,
                    deviceInfo: {},
                    locations: [],
                    codecs: [],
                    sipMessages: [],
                    callStatus: null,
                    releaseReason: null,
                    verificationStatus: null
                };
            }

            parse() {
                // Split into individual message blocks
                const messageBlocks = this.splitIntoMessages(this.rawData);

                for (const block of messageBlocks) {
                    const parsed = this.parseMessageBlock(block);
                    if (parsed) {
                        this.messages.push(parsed);
                        this.extractCallInfo(parsed);
                    }
                }

                // Calculate call duration if we have both answer and end times
                if (this.callInfo.answerTime && this.callInfo.endTime) {
                    const start = this.parseTimestamp(this.callInfo.answerTime);
                    const end = this.parseTimestamp(this.callInfo.endTime);
                    if (start && end) {
                        this.callInfo.duration = Math.round((end - start) / 1000);
                    }
                }

                // Sort messages by timestamp
                this.messages.sort((a, b) => {
                    const timeA = this.parseTimestamp(a.timestamp);
                    const timeB = this.parseTimestamp(b.timestamp);
                    return (timeA || 0) - (timeB || 0);
                });

                return this;
            }

            splitIntoMessages(data) {
                // Split by message type headers
                const messageTypes = [
                    'termAttempt', 'origAttempt', 'directSignalReporting',
                    'ccOpen', 'ccClose', 'answer', 'release',
                    'ims_3gpp_VoIP_answer', 'ims_3gpp_VoIP_release',
                    'smsMessage', 'mmsMessage'
                ];

                const blocks = [];
                const lines = data.split('\n');
                let currentBlock = [];
                let inBlock = false;

                for (const line of lines) {
                    // Check if this line starts a new message type
                    const isNewMessage = messageTypes.some(type =>
                        line.trim().startsWith(type) ||
                        line.includes('laesMessage') ||
                        (line.match(/^[A-Za-z].*Version \d/) && currentBlock.length > 0)
                    );

                    if (line.match(/^[A-Za-z].*Version \d/) && currentBlock.length > 0) {
                        // Save previous block and start new one
                        blocks.push(currentBlock.join('\n'));
                        currentBlock = [line];
                        inBlock = true;
                    } else {
                        currentBlock.push(line);
                        inBlock = true;
                    }
                }

                if (currentBlock.length > 0) {
                    blocks.push(currentBlock.join('\n'));
                }

                return blocks;
            }

            parseMessageBlock(block) {
                const result = {
                    rawBlock: block,
                    type: null,
                    timestamp: null,
                    caseId: null,
                    callId: null,
                    data: {}
                };

                // Determine message type
                if (block.includes('uuContent') || block.includes('ims_3GPP_VOIP_uuContent')) {
                    result.type = 'uuContent';
                } else if (block.includes('termAttempt') && !block.includes('ims_3gpp')) {
                    result.type = 'termAttempt';
                } else if (block.includes('origAttempt')) {
                    result.type = 'origAttempt';
                } else if (block.includes('directSignalReporting')) {
                    result.type = 'directSignalReporting';
                } else if (block.includes('ccOpen')) {
                    result.type = 'ccOpen';
                } else if (block.includes('ccClose')) {
                    result.type = 'ccClose';
                } else if (block.includes('ims_3gpp_VoIP_answer') || (block.includes('answer') && block.includes('answering'))) {
                    result.type = 'answer';
                } else if (block.includes('ims_3gpp_VoIP_release') || (block.includes('release') && block.includes('cause'))) {
                    result.type = 'release';
                }

                // Extract common fields
                result.caseId = this.extractField(block, 'caseId');
                result.timestamp = this.extractField(block, 'timestamp');
                result.callId = this.extractNestedField(block, 'callId', 'main') ||
                               this.extractNestedField(block, 'contentIdentifier', 'main');

                // Extract type-specific data
                switch (result.type) {
                    case 'termAttempt':
                    case 'origAttempt':
                        result.data = this.parseAttemptMessage(block);
                        break;
                    case 'directSignalReporting':
                        result.data = this.parseSIPMessage(block);
                        break;
                    case 'ccOpen':
                    case 'ccClose':
                        result.data = this.parseCCMessage(block);
                        break;
                    case 'answer':
                        result.data = this.parseAnswerMessage(block);
                        break;
                    case 'release':
                        result.data = this.parseReleaseMessage(block);
                        break;
                    case 'uuContent':
                        result.data = this.parseUUContentMessage(block);
                        break;
                }

                return result;
            }

            extractField(block, fieldName) {
                const regex = new RegExp(`${fieldName}\\s*=\\s*(.+?)(?:\\n|$)`, 'i');
                const match = block.match(regex);
                return match ? match[1].trim() : null;
            }

            extractNestedField(block, parentField, childField) {
                const regex = new RegExp(`${parentField}[\\s\\S]*?${childField}\\s*=\\s*(.+?)(?:\\n|$)`, 'i');
                const match = block.match(regex);
                return match ? match[1].trim() : null;
            }

            parseAttemptMessage(block) {
                const data = {
                    calling: {},
                    called: {},
                    sdp: null
                };

                // Extract calling party info
                const callingSection = block.match(/calling\s*\n([\s\S]*?)(?=called|$)/i);
                if (callingSection) {
                    const uriMatch = callingSection[1].match(/uri\[0\]\s*=\s*(.+)/i);
                    if (uriMatch) data.calling.uri = uriMatch[1].trim();

                    // Extract phone number from URI
                    const phoneMatch = data.calling.uri?.match(/\+(\d+)/);
                    if (phoneMatch) data.calling.phoneNumber = '+' + phoneMatch[1];

                    // Extract headers
                    const headerMatches = callingSection[1].matchAll(/sipHeader\[\d+\]\s*=\s*(.+)/gi);
                    data.calling.headers = [];
                    for (const match of headerMatches) {
                        data.calling.headers.push(match[1].trim());

                        // Extract caller name from P-Asserted-Identity
                        const nameMatch = match[1].match(/"([^"]+)"/);
                        if (nameMatch) data.calling.callerName = nameMatch[1];
                    }
                }

                // Extract called party info
                const calledSection = block.match(/called\s*\n([\s\S]*?)(?=associateMedia|location|$)/i);
                if (calledSection) {
                    const uriMatch = calledSection[1].match(/uri\[0\]\s*=\s*(.+)/i);
                    if (uriMatch) data.called.uri = uriMatch[1].trim();

                    const phoneMatch = data.called.uri?.match(/\+(\d+)/);
                    if (phoneMatch) data.called.phoneNumber = '+' + phoneMatch[1];

                    const headerMatches = calledSection[1].matchAll(/sipHeader\[\d+\]\s*=\s*(.+)/gi);
                    data.called.headers = [];
                    for (const match of headerMatches) {
                        data.called.headers.push(match[1].trim());
                    }
                }

                // Extract SDP (codec info)
                const sdpMatch = block.match(/sdp\s*=\s*([\s\S]*?)(?=\n\s*\n|\n[a-zA-Z])/);
                if (sdpMatch) {
                    data.sdp = sdpMatch[1].trim();
                    data.codecs = this.parseCodecsFromSDP(data.sdp);
                }

                return data;
            }

            parseSIPMessage(block) {
                const data = {
                    sipMessages: [],
                    correlationId: null
                };

                data.correlationId = this.extractField(block, 'correlationID');

                // Extract SIP message content
                const sigMsgMatch = block.match(/sigMsg\s*=\s*([\s\S]*?)(?=\[bin\]|$)/);
                if (sigMsgMatch) {
                    const sipContent = sigMsgMatch[1].trim();
                    data.sipMessages.push({
                        content: sipContent,
                        parsed: this.parseSIPContent(sipContent)
                    });
                }

                return data;
            }

            parseSIPContent(sipContent) {
                const parsed = {
                    method: null,
                    statusCode: null,
                    statusText: null,
                    headers: {},
                    isRequest: false,
                    isResponse: false
                };

                const lines = sipContent.split('\n');
                if (lines.length === 0) return parsed;

                const firstLine = lines[0].trim();

                // Check if it's a request or response
                if (firstLine.startsWith('SIP/2.0')) {
                    parsed.isResponse = true;
                    const statusMatch = firstLine.match(/SIP\/2\.0\s+(\d+)\s+(.+)/);
                    if (statusMatch) {
                        parsed.statusCode = parseInt(statusMatch[1]);
                        parsed.statusText = statusMatch[2];
                    }
                } else {
                    parsed.isRequest = true;
                    const methodMatch = firstLine.match(/^(\w+)\s+/);
                    if (methodMatch) {
                        parsed.method = methodMatch[1];
                    }
                }

                // Parse headers
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    const headerMatch = line.match(/^([^:]+):\s*(.+)/);
                    if (headerMatch) {
                        const headerName = headerMatch[1].trim();
                        const headerValue = headerMatch[2].trim();

                        if (parsed.headers[headerName]) {
                            if (Array.isArray(parsed.headers[headerName])) {
                                parsed.headers[headerName].push(headerValue);
                            } else {
                                parsed.headers[headerName] = [parsed.headers[headerName], headerValue];
                            }
                        } else {
                            parsed.headers[headerName] = headerValue;
                        }
                    }
                }

                return parsed;
            }

            parseCCMessage(block) {
                const data = {
                    sdp: null,
                    codecs: []
                };

                // Extract SDP from subjectMedia or associateMedia
                const sdpMatch = block.match(/sdp\s*=\s*([\s\S]*?)(?=\n\s*(?:associateMedia|deliveryIdentifier)|$)/);
                if (sdpMatch) {
                    data.sdp = sdpMatch[1].trim();
                    data.codecs = this.parseCodecsFromSDP(data.sdp);
                }

                return data;
            }

            parseAnswerMessage(block) {
                const data = {
                    answering: {},
                    location: []
                };

                // Extract answering party
                const answeringSection = block.match(/answering\s*\n([\s\S]*?)(?=location|$)/i);
                if (answeringSection) {
                    const uriMatch = answeringSection[1].match(/uri\[0\]\s*=\s*(.+)/i);
                    if (uriMatch) data.answering.uri = uriMatch[1].trim();

                    const phoneMatch = data.answering.uri?.match(/\+(\d+)/);
                    if (phoneMatch) data.answering.phoneNumber = '+' + phoneMatch[1];
                }

                // Extract location
                data.location = this.parseLocationData(block);

                return data;
            }

            parseReleaseMessage(block) {
                const data = {
                    cause: null,
                    location: []
                };

                // Extract cause
                const causeSection = block.match(/cause\s*\n([\s\S]*?)(?=contactAddresses|location|$)/i);
                if (causeSection) {
                    const sigTypeMatch = causeSection[1].match(/signalingType\s*=\s*(.+)/i);
                    if (sigTypeMatch) data.cause = sigTypeMatch[1].trim();
                }

                // Extract location
                data.location = this.parseLocationData(block);

                return data;
            }

            parseUUContentMessage(block) {
                const data = {
                    sipMessage: null,
                    smsData: null,
                    direction: null,
                    fromNumber: null,
                    toNumber: null,
                    messageText: null,
                    deviceInfo: {},
                    location: null
                };

                // Extract the hex-encoded signaling message
                const sigMsgMatch = block.match(/signalingMsg\[0\]\s*=\s*([0-9a-fA-F]+)/);
                if (sigMsgMatch) {
                    const hexData = sigMsgMatch[1];
                    const decoded = this.hexToString(hexData);
                    data.sipMessage = decoded;

                    // Parse the decoded SIP MESSAGE
                    const sipParsed = this.parseSIPContent(decoded);
                    data.sipParsed = sipParsed;

                    // Extract phone numbers from SIP headers
                    if (sipParsed.headers) {
                        // From header
                        const fromHeader = sipParsed.headers['From'] || sipParsed.headers['P-Preferred-Identity'] || sipParsed.headers['P-Asserted-Identity'];
                        if (fromHeader) {
                            const fromMatch = fromHeader.match(/sip:(\+?1?\d{10,})/i) || fromHeader.match(/(\d{10,})/);
                            if (fromMatch) data.fromNumber = this.normalizePhoneNumber(fromMatch[1]);
                        }

                        // To header
                        const toHeader = sipParsed.headers['To'];
                        if (toHeader) {
                            const toMatch = toHeader.match(/sip:(\+?1?\d{10,})/i) || toHeader.match(/(\d{10,})/);
                            if (toMatch) data.toNumber = this.normalizePhoneNumber(toMatch[1]);
                        }

                        // User-Agent for device info
                        const ua = sipParsed.headers['User-Agent'];
                        if (ua) {
                            data.deviceInfo.userAgent = ua;
                            // Parse iOS device
                            const iosMatch = ua.match(/iOS\/([^\s]+)\s+(\w+)/i);
                            if (iosMatch) {
                                data.deviceInfo.manufacturer = 'Apple';
                                data.deviceInfo.osVersion = iosMatch[1];
                                data.deviceInfo.model = iosMatch[2];
                            }
                        }

                        // Location from P-Access-Network-Info
                        const pani = sipParsed.headers['P-Access-Network-Info'];
                        if (pani) {
                            data.location = {
                                rawData: pani,
                                parsed: {}
                            };
                            // Detect network type
                            if (pani.includes('3GPP-NR')) {
                                data.location.networkType = '5G NR';
                            } else if (pani.includes('3GPP-E-UTRAN')) {
                                data.location.networkType = '4G LTE';
                            } else if (pani.includes('3GPP-UTRAN')) {
                                data.location.networkType = '3G UMTS';
                            }
                            // Extract cell ID
                            const cellMatch = pani.match(/utran-cell-id-3gpp=(\w+)/i);
                            if (cellMatch) {
                                data.location.parsed = this.parseCellId(cellMatch[1]);
                            }
                        }

                        // Determine direction based on In-Reply-To header
                        if (sipParsed.headers['In-Reply-To']) {
                            data.direction = 'Outgoing (Reply from Target)';
                        } else {
                            data.direction = 'Incoming (To Target)';
                        }
                    }

                    // Try to extract SMS content from body
                    // The SMS PDU is at the end of the SIP message after the headers
                    const bodyMatch = decoded.match(/Content-Length:\s*\d+\r?\n\r?\n([\s\S]+)$/);
                    if (bodyMatch) {
                        const smsPdu = bodyMatch[1];
                        data.smsData = this.parseSMSPDU(smsPdu);
                        if (data.smsData?.messageText) {
                            data.messageText = data.smsData.messageText;
                        }
                    }
                }

                return data;
            }

            hexToString(hex) {
                let str = '';
                for (let i = 0; i < hex.length; i += 2) {
                    const charCode = parseInt(hex.substr(i, 2), 16);
                    str += String.fromCharCode(charCode);
                }
                return str;
            }

            normalizePhoneNumber(number) {
                // Remove any non-digit characters except +
                let cleaned = number.replace(/[^\d+]/g, '');
                // Ensure it starts with +
                if (!cleaned.startsWith('+')) {
                    if (cleaned.length === 10) {
                        cleaned = '+1' + cleaned;
                    } else if (cleaned.length === 11 && cleaned.startsWith('1')) {
                        cleaned = '+' + cleaned;
                    }
                }
                return cleaned;
            }

            parseSMSPDU(pduData) {
                // Parse 3GPP SMS PDU (TS 23.040)
                const result = {
                    messageText: null,
                    smscNumber: null,
                    senderNumber: null,
                    timestamp: null,
                    encoding: null,
                    rawPdu: null
                };

                try {
                    // Convert to hex if it's binary data
                    let hexPdu = '';
                    for (let i = 0; i < pduData.length; i++) {
                        hexPdu += pduData.charCodeAt(i).toString(16).padStart(2, '0');
                    }
                    result.rawPdu = hexPdu;

                    // Try to decode as GSM 7-bit or find readable text
                    const decodedText = this.decodeGSM7BitText(hexPdu);
                    if (decodedText && decodedText.length > 0) {
                        result.messageText = decodedText;
                    }
                } catch (e) {
                    console.log('SMS PDU parsing error:', e);
                }

                return result;
            }

            decodeGSM7BitText(hexPdu) {
                // GSM 7-bit default alphabet mapping
                const gsm7bitChars = '@\u00a3$\u00a5\u00e8\u00e9\u00f9\u00ec\u00f2\u00c7\n\u00d8\u00f8\r\u00c5\u00e5\u0394_\u03a6\u0393\u039b\u03a9\u03a0\u03a8\u03a3\u0398\u039e \u00c6\u00e6\u00df\u00c9 !"#\u00a4%&\'()*+,-./0123456789:;<=>?\u00a1ABCDEFGHIJKLMNOPQRSTUVWXYZ\u00c4\u00d6\u00d1\u00dc\u00a7\u00bfabcdefghijklmnopqrstuvwxyz\u00e4\u00f6\u00f1\u00fc\u00e0';

                // First try to find printable ASCII text directly in the hex
                let text = '';
                let foundText = false;
                let consecutiveReadable = 0;

                for (let i = 0; i < hexPdu.length; i += 2) {
                    const byte = parseInt(hexPdu.substr(i, 2), 16);
                    if (byte >= 32 && byte < 127) {
                        text += String.fromCharCode(byte);
                        consecutiveReadable++;
                        if (consecutiveReadable > 3) foundText = true;
                    } else if (byte === 0x0d || byte === 0x0a) {
                        text += ' ';
                    } else {
                        if (text.length > 0 && consecutiveReadable > 3) {
                            text += ' ';
                        }
                        consecutiveReadable = 0;
                    }
                }

                // Clean up the text
                text = text.replace(/\s+/g, ' ').trim();

                // Try GSM 7-bit decoding if we didn't find good ASCII
                if (!foundText || text.length < 5) {
                    let gsm7Text = '';
                    try {
                        // Skip the SMS header (variable length) and try to decode the user data
                        // This is a simplified approach - real PDU parsing is more complex
                        const bytes = [];
                        for (let i = 0; i < hexPdu.length; i += 2) {
                            bytes.push(parseInt(hexPdu.substr(i, 2), 16));
                        }

                        // Try decoding as packed 7-bit from various offsets
                        for (let offset = 0; offset < Math.min(30, bytes.length); offset++) {
                            const decoded = this.unpack7Bit(bytes.slice(offset));
                            if (decoded && decoded.length > 5) {
                                // Check if it looks like readable text
                                let readable = 0;
                                for (const ch of decoded) {
                                    const code = ch.charCodeAt(0);
                                    if ((code >= 32 && code < 127) || code > 160) {
                                        readable++;
                                    }
                                }
                                if (readable > decoded.length * 0.7) {
                                    gsm7Text = decoded;
                                    break;
                                }
                            }
                        }
                    } catch (e) {}

                    if (gsm7Text && gsm7Text.length > text.length) {
                        text = gsm7Text;
                    }
                }

                return text || null;
            }

            unpack7Bit(bytes) {
                const gsm7bitChars = '@\u00a3$\u00a5\u00e8\u00e9\u00f9\u00ec\u00f2\u00c7\n\u00d8\u00f8\r\u00c5\u00e5\u0394_\u03a6\u0393\u039b\u03a9\u03a0\u03a8\u03a3\u0398\u039e \u00c6\u00e6\u00df\u00c9 !"#\u00a4%&\'()*+,-./0123456789:;<=>?\u00a1ABCDEFGHIJKLMNOPQRSTUVWXYZ\u00c4\u00d6\u00d1\u00dc\u00a7\u00bfabcdefghijklmnopqrstuvwxyz\u00e4\u00f6\u00f1\u00fc\u00e0';

                let result = '';
                let shift = 0;
                let carry = 0;

                for (let i = 0; i < bytes.length && result.length < 160; i++) {
                    const byte = bytes[i];
                    const char = ((byte << shift) | carry) & 0x7f;
                    carry = byte >> (7 - shift);
                    shift++;

                    if (char < gsm7bitChars.length) {
                        result += gsm7bitChars[char];
                    }

                    if (shift === 7) {
                        if (carry < gsm7bitChars.length) {
                            result += gsm7bitChars[carry];
                        }
                        shift = 0;
                        carry = 0;
                    }
                }

                return result;
            }

            parseLocationData(block) {
                const locations = [];
                const locationMatches = block.matchAll(/location\[\d+\]\s*\n\s*locationType\s*=\s*(.+)\n\s*locationData\s*=\s*(.+)/gi);

                for (const match of locationMatches) {
                    const locationData = {
                        type: match[1].trim(),
                        rawData: match[2].trim(),
                        parsed: {}
                    };

                    // Parse cell tower info from P-Access-Network-Info
                    const cellMatch = locationData.rawData.match(/utran-cell-id-3gpp=(\d+)/i);
                    if (cellMatch) {
                        const cellId = cellMatch[1];
                        locationData.parsed = this.parseCellId(cellId);
                    }

                    locations.push(locationData);
                }

                return locations;
            }

            parseCellId(cellId) {
                // Parse 3GPP cell ID format: MCC (3) + MNC (2-3) + LAC/TAC (4-5 hex) + Cell ID (7-8 hex)
                // Example: 311480550414df40c
                // For LTE: Cell ID = (eNodeB ID * 256) + Sector ID
                const result = {
                    fullCellId: cellId,
                    mcc: null,
                    mnc: null,
                    lac: null,      // TAC for LTE
                    cellId: null,   // Full cell ID in hex
                    cellIdDecimal: null,
                    eNodeBId: null, // For LTE: tower identifier
                    sectorId: null, // For LTE: sector (0-255)
                    tacDecimal: null,
                    networkType: null
                };

                if (cellId.length >= 15) {
                    result.mcc = cellId.substring(0, 3);
                    result.mnc = cellId.substring(3, 6);
                    // The remaining is TAC + Cell ID in hex
                    const tacAndCell = cellId.substring(6);
                    result.lac = tacAndCell.substring(0, 4);
                    result.cellId = tacAndCell.substring(4);

                    // Convert to decimal and extract eNodeB/sector
                    if (result.cellId) {
                        result.cellIdDecimal = parseInt(result.cellId, 16);
                        // LTE cell ID format: eNodeB ID (20 bits) + Sector ID (8 bits)
                        result.eNodeBId = Math.floor(result.cellIdDecimal / 256);
                        result.sectorId = result.cellIdDecimal % 256;
                    }

                    if (result.lac) {
                        result.tacDecimal = parseInt(result.lac, 16);
                    }

                    // Determine network type based on cell ID length
                    if (result.cellId && result.cellId.length >= 7) {
                        result.networkType = 'LTE/5G';
                    } else {
                        result.networkType = '3G/2G';
                    }
                }

                return result;
            }

            parseCodecsFromSDP(sdp) {
                const codecs = [];
                const rtpmapMatches = sdp.matchAll(/a=rtpmap:(\d+)\s+([^\s\/]+)/g);

                for (const match of rtpmapMatches) {
                    codecs.push({
                        payloadType: match[1],
                        name: match[2]
                    });
                }

                return codecs;
            }

            extractCallInfo(message) {
                if (message.caseId) this.callInfo.caseId = message.caseId;
                if (message.callId) this.callInfo.callId = message.callId;

                switch (message.type) {
                    case 'termAttempt':
                        this.callInfo.callDirection = 'Incoming';
                        this.callInfo.callType = 'Voice Call';
                        this.callInfo.startTime = message.timestamp;
                        if (message.data.calling) {
                            this.callInfo.callingParty = message.data.calling;
                            if (message.data.calling.callerName) {
                                this.callInfo.callerName = message.data.calling.callerName;
                            }
                        }
                        if (message.data.called) {
                            this.callInfo.calledParty = message.data.called;
                        }
                        if (message.data.codecs) {
                            this.callInfo.codecs = message.data.codecs;
                        }
                        break;

                    case 'origAttempt':
                        this.callInfo.callDirection = 'Outgoing';
                        this.callInfo.callType = 'Voice Call';
                        this.callInfo.startTime = message.timestamp;
                        if (message.data.calling) {
                            this.callInfo.callingParty = message.data.calling;
                        }
                        if (message.data.called) {
                            this.callInfo.calledParty = message.data.called;
                        }
                        break;

                    case 'directSignalReporting':
                        if (message.data.sipMessages) {
                            for (const sip of message.data.sipMessages) {
                                this.callInfo.sipMessages.push({
                                    timestamp: message.timestamp,
                                    ...sip
                                });

                                // Extract additional info from SIP headers
                                if (sip.parsed?.headers) {
                                    // Caller name from P-Asserted-Identity
                                    const pai = sip.parsed.headers['P-Asserted-Identity'];
                                    if (pai) {
                                        const nameMatch = (Array.isArray(pai) ? pai[0] : pai).match(/"([^"]+)"/);
                                        if (nameMatch && !this.callInfo.callerName) {
                                            this.callInfo.callerName = nameMatch[1];
                                        }
                                    }

                                    // Device info from User-Agent
                                    const ua = sip.parsed.headers['User-Agent'];
                                    if (ua) {
                                        this.callInfo.deviceInfo.userAgent = ua;
                                        // Parse Apple device
                                        const appleMatch = ua.match(/APPLE---([^-]+)---(.+)/);
                                        if (appleMatch) {
                                            this.callInfo.deviceInfo.manufacturer = 'Apple';
                                            this.callInfo.deviceInfo.model = appleMatch[1];
                                            this.callInfo.deviceInfo.osVersion = appleMatch[2];
                                        }
                                    }

                                    // Location from P-Access-Network-Info
                                    const pani = sip.parsed.headers['P-Access-Network-Info'];
                                    if (pani) {
                                        const cellMatch = (Array.isArray(pani) ? pani[0] : pani).match(/utran-cell-id-3gpp=(\w+)/i);
                                        if (cellMatch) {
                                            const existingLoc = this.callInfo.locations.find(l =>
                                                l.parsed?.fullCellId === cellMatch[1]
                                            );
                                            if (!existingLoc) {
                                                this.callInfo.locations.push({
                                                    type: 'P-A-N-I-Header',
                                                    rawData: pani,
                                                    parsed: this.parseCellId(cellMatch[1]),
                                                    timestamp: message.timestamp
                                                });
                                            }
                                        }
                                    }

                                    // Verification status
                                    const verstat = sip.parsed.headers['P-Com.NameId-Reputation'];
                                    if (verstat) {
                                        const verMatch = verstat.match(/verstat=([^;]+)/);
                                        if (verMatch) {
                                            this.callInfo.verificationStatus = verMatch[1];
                                        }
                                    }
                                }
                            }
                        }
                        break;

                    case 'answer':
                        this.callInfo.answerTime = message.timestamp;
                        this.callInfo.callStatus = 'Answered';
                        if (message.data.location) {
                            this.callInfo.locations.push(...message.data.location);
                        }
                        break;

                    case 'release':
                        this.callInfo.endTime = message.timestamp;
                        this.callInfo.releaseReason = message.data.cause;
                        if (message.data.location) {
                            this.callInfo.locations.push(...message.data.location);
                        }
                        break;

                    case 'ccOpen':
                        if (message.data.codecs && message.data.codecs.length > 0) {
                            this.callInfo.codecs = message.data.codecs;
                        }
                        break;

                    case 'uuContent':
                        // This is an SMS/MMS message
                        this.callInfo.callType = 'SMS Message';
                        this.smsMessages.push({
                            timestamp: message.timestamp,
                            caseId: message.caseId,
                            callId: message.callId,
                            ...message.data
                        });

                        // Update call info with SMS details
                        if (message.data.fromNumber) {
                            if (message.data.direction?.includes('Outgoing')) {
                                // Target is sending
                                if (!this.callInfo.callingParty.phoneNumber) {
                                    this.callInfo.callingParty.phoneNumber = message.data.fromNumber;
                                }
                            } else {
                                // Someone sending to target
                                if (!this.callInfo.calledParty.phoneNumber) {
                                    this.callInfo.calledParty.phoneNumber = message.data.fromNumber;
                                }
                            }
                        }
                        if (message.data.toNumber) {
                            if (message.data.direction?.includes('Outgoing')) {
                                if (!this.callInfo.calledParty.phoneNumber) {
                                    this.callInfo.calledParty.phoneNumber = message.data.toNumber;
                                }
                            } else {
                                if (!this.callInfo.callingParty.phoneNumber) {
                                    this.callInfo.callingParty.phoneNumber = message.data.toNumber;
                                }
                            }
                        }

                        // Device info
                        if (message.data.deviceInfo?.userAgent) {
                            this.callInfo.deviceInfo = {
                                ...this.callInfo.deviceInfo,
                                ...message.data.deviceInfo
                            };
                        }

                        // Location
                        if (message.data.location) {
                            this.callInfo.locations.push({
                                type: 'P-A-N-I-Header',
                                ...message.data.location,
                                timestamp: message.timestamp
                            });
                        }
                        break;
                }
            }

            parseTimestamp(timestamp) {
                if (!timestamp) return null;

                // Format: 20250604035420.132Z
                const match = timestamp.match(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\.?(\d*)Z?/);
                if (match) {
                    const [_, year, month, day, hour, min, sec, ms] = match;
                    const isoString = `${year}-${month}-${day}T${hour}:${min}:${sec}.${ms || '000'}Z`;
                    return new Date(isoString);
                }
                return null;
            }

            formatTimestamp(timestamp) {
                const date = this.parseTimestamp(timestamp);
                if (!date) return timestamp || 'Unknown';

                return date.toLocaleString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true,
                    timeZoneName: 'short'
                });
            }

            formatPhoneNumber(number) {
                if (!number) return 'Unknown';

                // Remove + and format as US number
                const digits = number.replace(/\D/g, '');
                if (digits.length === 11 && digits.startsWith('1')) {
                    return `+1 (${digits.substring(1, 4)}) ${digits.substring(4, 7)}-${digits.substring(7)}`;
                } else if (digits.length === 10) {
                    return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6)}`;
                }
                return number;
            }

            formatDuration(seconds) {
                if (!seconds || seconds < 0) return 'N/A';

                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;

                if (hours > 0) {
                    return `${hours}h ${minutes}m ${secs}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }
        }

        // UI Functions
        function analyzeCDC() {
            const input = document.getElementById('cdcInput').value;
            if (!input.trim()) {
                alert('Please paste CDC data to analyze.');
                return;
            }

            const analyzer = new CDCAnalyzer(input);
            analyzer.parse();

            displayResults(analyzer);
        }

        function displayResults(analyzer) {
            const container = document.getElementById('resultsContainer');
            container.classList.add('active');

            const info = analyzer.callInfo;
            const isSMS = info.callType === 'SMS Message' || analyzer.smsMessages.length > 0;

            let html = '';

            // Explanation Panel
            if (isSMS) {
                html += `
                    <div class="explanation-panel">
                        <h3>What This Data Shows</h3>
                        <p>This is <strong>CALEA (Communications Assistance for Law Enforcement Act)</strong> SMS intercept data from a phone carrier.
                        The data captures text messages sent via IMS (IP Multimedia Subsystem) / RCS / VoLTE messaging.</p>
                        <ul>
                            <li><strong>uuContent</strong> - User-to-User Content containing SMS/MMS data</li>
                            <li><strong>SIP MESSAGE</strong> - The protocol used to send SMS over IMS networks</li>
                            <li><strong>3GPP SMS PDU</strong> - Protocol Data Unit containing the actual message</li>
                        </ul>
                    </div>
                `;
            } else {
                html += `
                    <div class="explanation-panel">
                        <h3>What This Data Shows</h3>
                        <p>This is <strong>CALEA (Communications Assistance for Law Enforcement Act)</strong> intercept data from a phone carrier.
                        The data captures communication events in real-time as they occur on the network.</p>
                        <ul>
                            <li><strong>T1.678</strong> - Industry standard format for delivering intercept data</li>
                            <li><strong>LAES</strong> - Lawfully Authorized Electronic Surveillance message format</li>
                            <li><strong>SIP</strong> - Session Initiation Protocol (how VoIP/VoLTE calls are set up)</li>
                        </ul>
                    </div>
                `;
            }

            // Summary Cards
            html += '<div class="summary-grid">';

            // Call Overview Card
            html += `
                <div class="summary-card highlight">
                    <h3>Call Overview</h3>
                    <div class="info-row">
                        <span class="info-label">Call Type</span>
                        <span class="info-value"><span class="badge badge-info">${info.callType || 'Voice Call'}</span></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Direction</span>
                        <span class="info-value"><span class="badge ${info.callDirection === 'Incoming' ? 'badge-success' : 'badge-warning'}">${info.callDirection || 'Unknown'}</span></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Status</span>
                        <span class="info-value"><span class="badge ${info.callStatus === 'Answered' ? 'badge-success' : 'badge-warning'}">${info.callStatus || 'Unknown'}</span></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Call Duration</span>
                        <span class="info-value">${analyzer.formatDuration(info.duration)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Case ID</span>
                        <span class="info-value" style="font-family: monospace;">${info.caseId || 'N/A'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Call ID</span>
                        <span class="info-value" style="font-family: monospace; font-size: 0.8rem;">${info.callId || 'N/A'}</span>
                    </div>
                </div>
            `;

            // Calling Party Card
            html += `
                <div class="summary-card caller">
                    <h3>Calling Party (FROM)</h3>
                    <div class="info-row">
                        <span class="info-label">Phone Number</span>
                        <span class="info-value phone-number">${analyzer.formatPhoneNumber(info.callingParty.phoneNumber)}</span>
                    </div>
                    ${info.callerName ? `
                    <div class="info-row">
                        <span class="info-label">Caller ID Name</span>
                        <span class="info-value caller-name">${info.callerName}</span>
                    </div>
                    ` : ''}
                    ${info.verificationStatus ? `
                    <div class="info-row">
                        <span class="info-label">STIR/SHAKEN</span>
                        <span class="info-value"><span class="badge ${info.verificationStatus.includes('Passed') ? 'badge-success' : 'badge-warning'}">${info.verificationStatus}</span></span>
                    </div>
                    ` : ''}
                    <div class="info-row">
                        <span class="info-label">Carrier</span>
                        <span class="info-value">${info.callingParty.uri?.includes('t-mobile') ? 'T-Mobile' : 'Unknown'}</span>
                    </div>
                </div>
            `;

            // Called Party Card
            html += `
                <div class="summary-card called">
                    <h3>Called Party (TO)</h3>
                    <div class="info-row">
                        <span class="info-label">Phone Number</span>
                        <span class="info-value phone-number">${analyzer.formatPhoneNumber(info.calledParty.phoneNumber)}</span>
                    </div>
                    ${info.calledParty.uri?.includes('rn=') ? `
                    <div class="info-row">
                        <span class="info-label">Routing Number</span>
                        <span class="info-value" style="font-family: monospace;">${info.calledParty.uri.match(/rn=\+?(\d+)/)?.[1] || 'N/A'}</span>
                    </div>
                    ` : ''}
                    <div class="info-row">
                        <span class="info-label">Carrier</span>
                        <span class="info-value">${info.calledParty.uri?.includes('vzims') || info.sipMessages.some(s => s.content?.includes('vzims')) ? 'Verizon' : 'Unknown'}</span>
                    </div>
                </div>
            `;

            // Timestamps Card
            html += `
                <div class="summary-card">
                    <h3>Timestamps (All Times)</h3>
                    <div class="info-row">
                        <span class="info-label">Call Initiated</span>
                        <span class="info-value">${analyzer.formatTimestamp(info.startTime)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Call Answered</span>
                        <span class="info-value">${analyzer.formatTimestamp(info.answerTime)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Call Ended</span>
                        <span class="info-value">${analyzer.formatTimestamp(info.endTime)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">End Reason</span>
                        <span class="info-value">${info.releaseReason || 'Normal'}</span>
                    </div>
                </div>
            `;

            html += '</div>';

            // SMS Messages Section (if applicable)
            if (analyzer.smsMessages.length > 0) {
                html += `
                    <div class="device-section" style="border-left: 4px solid #48bb78;">
                        <h3>SMS Message Content</h3>
                        <p style="color: var(--text-muted); margin-bottom: 15px; font-size: 0.9rem;">
                            Text message content extracted from IMS/RCS messaging. Messages are shown in chronological order.
                        </p>
                `;

                for (const sms of analyzer.smsMessages) {
                    const direction = sms.direction || 'Unknown Direction';
                    const directionClass = direction.includes('Outgoing') ? 'badge-warning' : 'badge-success';
                    const directionIcon = direction.includes('Outgoing') ? '&rarr;' : '&larr;';

                    html += `
                        <div style="background: #f8fafc; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--border-color);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span class="badge ${directionClass}">${directionIcon} ${direction}</span>
                                <span class="timeline-time">${analyzer.formatTimestamp(sms.timestamp)}</span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong>From:</strong> <span class="phone-number" style="font-size: 1rem;">${analyzer.formatPhoneNumber(sms.fromNumber)}</span>
                                &nbsp;&nbsp;
                                <strong>To:</strong> <span class="phone-number" style="font-size: 1rem;">${analyzer.formatPhoneNumber(sms.toNumber)}</span>
                            </div>
                    `;

                    if (sms.messageText) {
                        html += `
                            <div style="background: white; padding: 15px; border-radius: 6px; border: 1px solid #e2e8f0; margin-top: 10px;">
                                <strong style="color: var(--text-muted); font-size: 0.85rem;">MESSAGE TEXT:</strong>
                                <p style="font-size: 1.1rem; margin-top: 8px; white-space: pre-wrap;">${escapeHtml(sms.messageText)}</p>
                            </div>
                        `;
                    } else if (sms.smsData?.rawPdu) {
                        html += `
                            <div style="background: #fffbeb; padding: 15px; border-radius: 6px; border: 1px solid #fcd34d; margin-top: 10px;">
                                <strong style="color: #92400e; font-size: 0.85rem;">RAW SMS PDU (Unable to fully decode):</strong>
                                <p style="font-family: monospace; font-size: 0.8rem; margin-top: 8px; word-break: break-all;">${sms.smsData.rawPdu.substring(0, 200)}${sms.smsData.rawPdu.length > 200 ? '...' : ''}</p>
                            </div>
                        `;
                    }

                    // Show location if available for this SMS
                    if (sms.location) {
                        html += `
                            <div style="margin-top: 10px; padding: 10px; background: #f0f9ff; border-radius: 4px; border: 1px solid #bae6fd;">
                                <strong style="font-size: 0.85rem; color: #0369a1;">Network Location:</strong>
                                <span style="margin-left: 10px;">${sms.location.networkType || 'Cellular'}</span>
                                ${sms.location.parsed?.fullCellId ? `<span style="margin-left: 10px; font-family: monospace; font-size: 0.85rem;">Cell: ${sms.location.parsed.fullCellId}</span>` : ''}
                            </div>
                        `;
                    }

                    html += '</div>';
                }

                html += '</div>';
            }

            // Device Information Section
            if (info.deviceInfo.userAgent) {
                html += `
                    <div class="device-section">
                        <h3>Device Information</h3>
                        <div class="device-grid">
                            ${info.deviceInfo.manufacturer ? `
                            <div class="device-item">
                                <h4>Manufacturer</h4>
                                <p>${info.deviceInfo.manufacturer}</p>
                            </div>
                            ` : ''}
                            ${info.deviceInfo.model ? `
                            <div class="device-item">
                                <h4>Device Model</h4>
                                <p>${info.deviceInfo.model}</p>
                            </div>
                            ` : ''}
                            ${info.deviceInfo.osVersion ? `
                            <div class="device-item">
                                <h4>OS Version</h4>
                                <p>iOS ${info.deviceInfo.osVersion}</p>
                            </div>
                            ` : ''}
                            <div class="device-item">
                                <h4>Full User Agent</h4>
                                <p style="font-size: 0.85rem; font-family: monospace;">${info.deviceInfo.userAgent}</p>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Location Information
            if (info.locations.length > 0) {
                html += `
                    <div class="location-section">
                        <h3>Location / Cell Tower Information</h3>
                        <p style="color: var(--text-muted); margin-bottom: 15px; font-size: 0.9rem;">
                            Cell tower information from the target device's network registration. This shows which cell tower(s) the device connected through during the call.
                        </p>
                `;

                // Deduplicate locations
                const uniqueLocations = [];
                const seen = new Set();
                for (const loc of info.locations) {
                    const key = loc.parsed?.fullCellId || loc.rawData;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueLocations.push(loc);
                    }
                }

                for (const loc of uniqueLocations) {
                    html += `
                        <div class="location-item">
                            <strong>Source:</strong> ${loc.type}<br>
                            <div class="cell-info">
                                ${loc.parsed?.mcc ? `
                                <div class="cell-detail">
                                    <label>MCC (Country)</label>
                                    <span>${loc.parsed.mcc}</span>
                                    <small style="display: block; color: var(--text-muted);">${loc.parsed.mcc === '311' ? 'USA' : ''}</small>
                                </div>
                                ` : ''}
                                ${loc.parsed?.mnc ? `
                                <div class="cell-detail">
                                    <label>MNC (Network)</label>
                                    <span>${loc.parsed.mnc}</span>
                                    <small style="display: block; color: var(--text-muted);">${getMNCCarrier(loc.parsed.mcc, loc.parsed.mnc)}</small>
                                </div>
                                ` : ''}
                                ${loc.parsed?.lac ? `
                                <div class="cell-detail">
                                    <label>TAC/LAC</label>
                                    <span>${loc.parsed.lac}</span>
                                </div>
                                ` : ''}
                                ${loc.parsed?.cellId ? `
                                <div class="cell-detail">
                                    <label>Cell ID (hex)</label>
                                    <span>${loc.parsed.cellId}</span>
                                    ${loc.parsed.cellId ? `<small style="display: block; color: var(--text-muted);">Decimal: ${parseInt(loc.parsed.cellId, 16)}</small>` : ''}
                                </div>
                                ` : ''}
                                ${loc.parsed?.cellId ? `
                                <div class="cell-detail">
                                    <label>eNodeB ID</label>
                                    <span>${Math.floor(parseInt(loc.parsed.cellId, 16) / 256)}</span>
                                    <small style="display: block; color: var(--text-muted);">Sector: ${parseInt(loc.parsed.cellId, 16) % 256}</small>
                                </div>
                                ` : ''}
                                <div class="cell-detail">
                                    <label>Full Cell ID String</label>
                                    <span style="font-size: 0.8rem;">${loc.parsed?.fullCellId || 'N/A'}</span>
                                </div>
                            </div>
                            ${loc.parsed?.mcc && loc.parsed?.mnc && loc.parsed?.cellId ? `
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                                <strong style="font-size: 0.85rem; color: var(--text-muted);">CELL SITE LOOKUP:</strong>
                                <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                    <a href="https://www.cellmapper.net/map?MCC=${loc.parsed.mcc}&MNC=${loc.parsed.mnc}&type=LTE&latitude=40&longitude=-74&zoom=10&showTowers=true&showTowerLabels=true&clusterEnabled=true&tilesEnabled=true&showOrphans=false&showNoFrequency498=false&showFrequency498=false&showBand498=false&mapType=undefined&showHex=false&showVerifiedOnly=false&showUnverifiedOnly=false&showLTE498=true&showENDC498=false&showNR498=false&new498=false&libertyUnited=false&oldState=false&blinds498=&history498=&tower=${Math.floor(parseInt(loc.parsed.cellId, 16) / 256)}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #3182ce; color: white; text-decoration: none; border-radius: 4px; font-size: 0.85rem;">
                                        CellMapper Lookup
                                    </a>
                                    <a href="https://opencellid.org/#zoom=14&lat=40&lon=-74" target="_blank" style="display: inline-block; padding: 8px 16px; background: #48bb78; color: white; text-decoration: none; border-radius: 4px; font-size: 0.85rem;">
                                        OpenCellID
                                    </a>
                                    <button onclick="copyToClipboard('MCC: ${loc.parsed.mcc}, MNC: ${loc.parsed.mnc}, TAC: ${parseInt(loc.parsed.lac, 16)}, CellID: ${parseInt(loc.parsed.cellId, 16)}, eNodeB: ${Math.floor(parseInt(loc.parsed.cellId, 16) / 256)}')" style="padding: 8px 16px; background: #718096; color: white; border: none; border-radius: 4px; font-size: 0.85rem; cursor: pointer;">
                                        Copy Cell Info
                                    </button>
                                </div>
                                <p style="margin-top: 10px; font-size: 0.8rem; color: var(--text-muted);">
                                    <strong>For carrier tower location:</strong> Submit a formal request to the carrier with the eNodeB ID (${Math.floor(parseInt(loc.parsed.cellId, 16) / 256)}) for exact coordinates.
                                </p>
                            </div>
                            ` : ''}
                            </div>
                        </div>
                    `;
                }

                html += '</div>';
            }

            // Audio Codecs
            if (info.codecs.length > 0) {
                html += `
                    <div class="device-section">
                        <h3>Audio Codecs (Media Capabilities)</h3>
                        <p style="color: var(--text-muted); margin-bottom: 10px; font-size: 0.9rem;">
                            These are the audio encoding formats negotiated for the call. VoLTE typically uses EVS or AMR-WB for HD voice.
                        </p>
                        <div class="codec-list">
                            ${info.codecs.map(c => `<span class="codec-badge">${c.name}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Timeline
            html += `
                <div class="timeline-section">
                    <h3>Call Event Timeline</h3>
                    <p style="color: var(--text-muted); margin-bottom: 20px; font-size: 0.9rem;">
                        Chronological sequence of events during this communication session.
                    </p>
                    <div class="timeline">
            `;

            for (const msg of analyzer.messages) {
                let eventClass = '';
                let eventTitle = '';
                let eventDetails = '';

                switch (msg.type) {
                    case 'termAttempt':
                        eventClass = 'event-start';
                        eventTitle = 'Incoming Call Attempt';
                        eventDetails = `From: ${analyzer.formatPhoneNumber(msg.data.calling?.phoneNumber)}  To: ${analyzer.formatPhoneNumber(msg.data.called?.phoneNumber)}`;
                        break;
                    case 'origAttempt':
                        eventClass = 'event-start';
                        eventTitle = 'Outgoing Call Attempt';
                        eventDetails = `From: ${analyzer.formatPhoneNumber(msg.data.calling?.phoneNumber)}  To: ${analyzer.formatPhoneNumber(msg.data.called?.phoneNumber)}`;
                        break;
                    case 'directSignalReporting':
                        if (msg.data.sipMessages?.[0]?.parsed) {
                            const sip = msg.data.sipMessages[0].parsed;
                            if (sip.isRequest) {
                                eventTitle = `SIP ${sip.method}`;
                                if (sip.method === 'INVITE') {
                                    eventDetails = 'Call setup request sent';
                                } else if (sip.method === 'PRACK') {
                                    eventDetails = 'Provisional acknowledgment';
                                } else if (sip.method === 'ACK') {
                                    eventDetails = 'Call establishment confirmed';
                                } else if (sip.method === 'BYE') {
                                    eventClass = 'event-end';
                                    eventDetails = 'Call termination request';
                                } else if (sip.method === 'UPDATE') {
                                    eventDetails = 'Session parameter update';
                                }
                            } else if (sip.isResponse) {
                                eventTitle = `SIP ${sip.statusCode} ${sip.statusText}`;
                                if (sip.statusCode === 180) {
                                    eventClass = 'event-ring';
                                    eventDetails = 'Phone is ringing';
                                } else if (sip.statusCode === 183) {
                                    eventDetails = 'Call progressing (early media)';
                                } else if (sip.statusCode === 200) {
                                    if (msg.data.sipMessages[0].content?.includes('INVITE')) {
                                        eventClass = 'event-answer';
                                        eventDetails = 'Call answered';
                                    } else {
                                        eventDetails = 'Request successful';
                                    }
                                }
                            }
                        } else {
                            eventTitle = 'SIP Signaling';
                            eventDetails = 'Network signaling message';
                        }
                        break;
                    case 'ccOpen':
                        eventTitle = 'Content Channel Opened';
                        eventDetails = 'Audio/media stream established';
                        break;
                    case 'ccClose':
                        eventClass = 'event-end';
                        eventTitle = 'Content Channel Closed';
                        eventDetails = 'Audio/media stream terminated';
                        break;
                    case 'answer':
                        eventClass = 'event-answer';
                        eventTitle = 'Call Answered';
                        eventDetails = `Answered by: ${analyzer.formatPhoneNumber(msg.data.answering?.phoneNumber)}`;
                        break;
                    case 'release':
                        eventClass = 'event-end';
                        eventTitle = 'Call Released';
                        eventDetails = `Reason: ${msg.data.cause || 'Normal termination'}`;
                        break;
                    case 'uuContent':
                        eventClass = msg.data.direction?.includes('Outgoing') ? 'event-start' : 'event-answer';
                        eventTitle = 'SMS Message';
                        const smsDir = msg.data.direction?.includes('Outgoing') ? 'Sent' : 'Received';
                        eventDetails = `${smsDir}: ${analyzer.formatPhoneNumber(msg.data.fromNumber)}  ${analyzer.formatPhoneNumber(msg.data.toNumber)}`;
                        if (msg.data.messageText) {
                            const preview = msg.data.messageText.length > 50
                                ? msg.data.messageText.substring(0, 50) + '...'
                                : msg.data.messageText;
                            eventDetails += `<br><em style="color: var(--text-color);">"${escapeHtml(preview)}"</em>`;
                        }
                        break;
                    default:
                        eventTitle = msg.type || 'Unknown Event';
                        eventDetails = '';
                }

                html += `
                    <div class="timeline-event ${eventClass}">
                        <div class="timeline-time">${analyzer.formatTimestamp(msg.timestamp)}</div>
                        <div class="timeline-title">${eventTitle}</div>
                        <div class="timeline-details">${eventDetails}</div>
                    </div>
                `;
            }

            html += '</div></div>';

            // Technical Details (collapsible)
            html += `
                <div class="technical-section collapsed">
                    <h3 onclick="toggleSection(this.parentElement)">Technical Details - SIP Messages</h3>
                    <div class="technical-content">
                        <p style="color: var(--text-muted); margin-bottom: 15px; font-size: 0.9rem;">
                            Raw SIP (Session Initiation Protocol) messages captured during the call. Click each to expand.
                        </p>
            `;

            for (const sip of info.sipMessages) {
                const parsed = sip.parsed;
                let label = 'SIP Message';
                if (parsed?.isRequest) {
                    label = `SIP ${parsed.method} Request`;
                } else if (parsed?.isResponse) {
                    label = `SIP ${parsed.statusCode} ${parsed.statusText}`;
                }

                html += `
                    <div class="message-type-label">${label}</div>
                    <div class="timeline-time" style="margin-bottom: 5px;">${analyzer.formatTimestamp(sip.timestamp)}</div>
                    <div class="sip-message">${escapeHtml(sip.content || '')}</div>
                `;
            }

            html += '</div></div>';

            // Raw Message Blocks (collapsible)
            html += `
                <div class="technical-section collapsed">
                    <h3 onclick="toggleSection(this.parentElement)">Raw CDC Message Blocks (${analyzer.messages.length} messages)</h3>
                    <div class="technical-content">
            `;

            for (const msg of analyzer.messages) {
                html += `
                    <div class="message-type-label">${msg.type || 'Unknown'}</div>
                    <div class="sip-message">${escapeHtml(msg.rawBlock)}</div>
                `;
            }

            html += '</div></div>';

            container.innerHTML = html;
        }

        function toggleSection(element) {
            element.classList.toggle('collapsed');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert('Cell info copied to clipboard!');
            }).catch(err => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('Cell info copied to clipboard!');
            });
        }

        function getMNCCarrier(mcc, mnc) {
            // US carriers (MCC 310, 311, 312, 313, 316)
            const usCarriers = {
                '310': {
                    '004': 'Verizon', '005': 'Verizon', '006': 'Verizon', '010': 'Verizon', '012': 'Verizon',
                    '013': 'Verizon', '590': 'Verizon', '890': 'Verizon', '910': 'Verizon',
                    '026': 'T-Mobile', '160': 'T-Mobile', '200': 'T-Mobile', '210': 'T-Mobile',
                    '220': 'T-Mobile', '230': 'T-Mobile', '240': 'T-Mobile', '250': 'T-Mobile',
                    '260': 'T-Mobile', '270': 'T-Mobile', '300': 'T-Mobile', '310': 'T-Mobile',
                    '330': 'T-Mobile', '490': 'T-Mobile', '530': 'T-Mobile', '580': 'T-Mobile',
                    '660': 'T-Mobile', '800': 'T-Mobile',
                    '030': 'AT&T', '070': 'AT&T', '090': 'AT&T', '150': 'AT&T', '170': 'AT&T',
                    '280': 'AT&T', '380': 'AT&T', '410': 'AT&T', '560': 'AT&T', '680': 'AT&T',
                    '980': 'AT&T',
                    '120': 'Sprint/T-Mobile', '830': 'Sprint/T-Mobile'
                },
                '311': {
                    '480': 'Verizon', '481': 'Verizon', '482': 'Verizon', '483': 'Verizon',
                    '484': 'Verizon', '485': 'Verizon', '486': 'Verizon', '487': 'Verizon',
                    '488': 'Verizon', '489': 'Verizon',
                    '490': 'T-Mobile', '660': 'T-Mobile', '882': 'T-Mobile', '490': 'T-Mobile',
                    '180': 'AT&T'
                },
                '312': {
                    '530': 'Sprint/T-Mobile'
                }
            };

            if (mcc && mnc && usCarriers[mcc] && usCarriers[mcc][mnc]) {
                return usCarriers[mcc][mnc];
            }

            // Check partial matches for 2-digit MNCs
            if (mcc && mnc && usCarriers[mcc]) {
                const mnc2 = mnc.substring(0, 2);
                const mnc3 = mnc.substring(0, 3);
                for (const [key, value] of Object.entries(usCarriers[mcc])) {
                    if (key === mnc3 || key === mnc2 || mnc.startsWith(key)) {
                        return value;
                    }
                }
            }

            return '';
        }

        function clearAll() {
            document.getElementById('cdcInput').value = '';
            document.getElementById('resultsContainer').classList.remove('active');
            document.getElementById('resultsContainer').innerHTML = '';
        }

        function loadSample() {
            // This would load sample data for testing
            document.getElementById('cdcInput').value = `termAttempt
T1.678 Version 4
   laesMessage
      termAttempt
         caseId = 6313754560
         iAPSystemId
            string_ = ZZ5
         timestamp = 20250604035420.132Z
         callId
            main = 003A1486D04F061E
         calling
            uri[0] = sip:+16313841232@msg.pc.t-mobile.com
            sipHeader[0] = From: sip:+16313841232@msg.pc.t-mobile.com
            sipHeader[1] = Contact: sip:mavodi-0-12e-9cf-e-fffff
            sipHeader[2] = P-Asserted-Identity: <sip:+16313841232;verstat=TN-Validation-Passed@msg.pc.t-mobile.com:5060;user=phone>
         called
            uri[0] = tel:+16313754560;phone-context=INPEER.TMOBILE.COM;npdi;rn=+16315996100
            sipHeader[0] = To:  <sip:+16313754560@msg.pc.t-mobile.com;user=phone>

Sample data loaded. Click "Analyze CDC Data" to parse.`;
        }
    </script>
</body>
</html>
